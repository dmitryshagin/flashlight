   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 116               	sendchar:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Ð§Ð°ÑÑ‚Ð¾Ñ‚Ð° ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð° (ÐºÐ²Ð°Ñ€Ñ†Ð°) */
  39:main.c        **** #define F_CPU 3686400UL
  40:main.c        **** 
  41:main.c        **** //TODO: TURN ON BT
  42:main.c        **** 
  43:main.c        **** #define BAUDRATE 38400UL
  44:main.c        **** 
  45:main.c        **** 
  46:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  47:main.c        **** 
  48:main.c        **** /*
  49:main.c        ****  * Ð’Ñ‹Ð±Ð¾Ñ€ Ð¿Ð¾Ñ€Ñ‚Ð° Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð²Ñ…Ð¾Ð´Ð° Ð² Ð·Ð°Ð³Ñ€ÑƒÐ·Ñ‡Ð¸Ðº
  50:main.c        ****  * Ð§Ñ‚Ð¾Ð±Ñ‹ Ð²Ð¾Ð¹Ñ‚Ð¸ Ð² Ð·Ð°Ð³Ñ€ÑƒÐ·Ñ‡Ð¸Ðº Ð½Ð°Ð´Ð¾ Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¸ Ð·Ð°Ð¿ÑƒÑÐºÐµ ÑÑ‚Ð° ÐºÐ
  51:main.c        ****  */
  52:main.c        **** #define BLPORT		PORTD
  53:main.c        **** #define BLDDR		DDRD
  54:main.c        **** #define BLPIN		PIND
  55:main.c        **** #define BLPNUM		PIND2
  56:main.c        **** 
  57:main.c        **** 
  58:main.c        **** #define PWRPORT		PORTD
  59:main.c        **** #define PWRDDR		DDRD
  60:main.c        **** #define PWRPNUM		PIND7
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** /*
  64:main.c        ****  * GREEN LED on - we are in bootloader
  65:main.c        ****  */
  66:main.c        **** 
  67:main.c        **** #define ENABLE_BOOT_LED
  68:main.c        **** #define BIPORT		PORTB
  69:main.c        **** #define BIDDR		DDRB
  70:main.c        **** #define BIPIN		PINB
  71:main.c        **** #define BIPNUM		PINB1
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** #define DISABLE_WDT_AT_STARTUP
  75:main.c        **** 
  76:main.c        **** /*
  77:main.c        ****  * Watchdog-reset is issued at exit 
  78:main.c        ****  * define the timeout-value here (see avr-libc manual)
  79:main.c        ****  */
  80:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  81:main.c        **** 
  82:main.c        **** // #define START_SIMPLE
  83:main.c        **** #define START_WAIT
  84:main.c        **** //#define START_POWERSAVE
  85:main.c        **** //#define START_BOOTICE
  86:main.c        **** 
  87:main.c        **** /* ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð»Ñ Ð²Ñ…Ð¾Ð´Ð° Ð² Ð·Ð°Ð³Ñ€ÑƒÐ·Ñ‡Ð¸Ðº Ð² START_WAIT */
  88:main.c        **** #define START_WAIT_UARTCHAR 'S'
  89:main.c        **** 
  90:main.c        **** /* Ð’Ñ‹Ð´ÐµÑ€Ð¶ÐºÐ° Ð´Ð»Ñ START_WAIT mode ( t = WAIT_TIME * 10ms ) */
  91:main.c        **** #define WAIT_VALUE 800 /* 800*10ms = 8sec */
  92:main.c        **** 
  93:main.c        **** /*
  94:main.c        ****  * enable/disable readout of fuse and lock-bits
  95:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
  96:main.c        ****  * to show the correct information).
  97:main.c        ****  */
  98:main.c        **** //#define ENABLEREADFUSELOCK
  99:main.c        **** 
 100:main.c        **** /* enable/disable write of lock-bits
 101:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 102:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 103:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 104:main.c        ****  * with a bootloader as far as I know)
 105:main.c        ****  * Keep this undefined!
 106:main.c        ****  */
 107:main.c        **** //#define WRITELOCKBITS
 108:main.c        **** 
 109:main.c        **** /*
 110:main.c        ****  * define the following if the bootloader should not output
 111:main.c        ****  * itself at flash read (will fake an empty boot-section)
 112:main.c        ****  */
 113:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 114:main.c        **** 
 115:main.c        **** #define VERSION_HIGH '0'
 116:main.c        **** #define VERSION_LOW  '8'
 117:main.c        **** 
 118:main.c        **** #define GET_LOCK_BITS           0x0001
 119:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 120:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 121:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 122:main.c        **** 
 123:main.c        **** /* Ð Ð°ÑÑ‡ÐµÑ‚ Ð´ÐµÐ»Ð¸Ñ‚ÐµÐ»Ñ Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñ‹ Ð´Ð»Ñ USART*/
 124:main.c        **** #ifdef UART_DOUBLESPEED
 125:main.c        **** 
 126:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 127:main.c        **** 
 128:main.c        **** #else
 129:main.c        **** 
 130:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 131:main.c        **** 
 132:main.c        **** #endif
 133:main.c        **** 
 134:main.c        **** 
 135:main.c        **** #include <stdint.h>
 136:main.c        **** #include <avr/io.h>
 137:main.c        **** #include <avr/wdt.h>
 138:main.c        **** #include <avr/boot.h>
 139:main.c        **** #include <avr/pgmspace.h>
 140:main.c        **** #include <avr/eeprom.h>
 141:main.c        **** #include <avr/interrupt.h>
 142:main.c        **** #include <util/delay.h>
 143:main.c        **** 
 144:main.c        **** #include "chipdef.h"
 145:main.c        **** 
 146:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 147:main.c        **** 
 148:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 149:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 150:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 151:main.c        **** 	// void __vector_default(void) { ; }
 152:main.c        **** 	void __vector_default(void) { ; }
 153:main.c        **** #endif
 154:main.c        **** 
 155:main.c        **** static void sendchar(uint8_t data)
 156:main.c        **** {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 124               	.L2:
 157:main.c        **** 	while (!(UART_STATUS & (1<<UART_TXREADY)));
 126               	.LM1:
 127 0000 9091 C000 		lds r25,192
 128 0004 95FF      		sbrs r25,5
 129 0006 00C0      		rjmp .L2
 158:main.c        **** 	UART_DATA = data;
 131               	.LM2:
 132 0008 8093 C600 		sts 198,r24
 133 000c 0895      		ret
 135               	.Lscope1:
 138               	recvchar:
 159:main.c        **** }
 160:main.c        **** 
 161:main.c        **** static uint8_t recvchar(void)
 162:main.c        **** {
 140               	.LM3:
 141               	.LFBB2:
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 0 */
 145               	.L__stack_usage = 0
 146               	.L7:
 163:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 148               	.LM4:
 149 000e 8091 C000 		lds r24,192
 150 0012 87FF      		sbrs r24,7
 151 0014 00C0      		rjmp .L7
 164:main.c        **** 	return UART_DATA;
 153               	.LM5:
 154 0016 8091 C600 		lds r24,198
 165:main.c        **** }
 156               	.LM6:
 157 001a 0895      		ret
 159               	.Lscope2:
 162               	send_boot:
 166:main.c        **** 
 167:main.c        **** static inline void eraseFlash(void)
 168:main.c        **** {
 169:main.c        **** 	// erase only main section (bootloader protection)
 170:main.c        **** 	uint32_t addr = 0;
 171:main.c        **** 	while (APP_END > addr) 
 172:main.c        **** 		{
 173:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 174:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 175:main.c        **** 		addr += SPM_PAGESIZE;
 176:main.c        **** 		}
 177:main.c        **** 	boot_rww_enable();
 178:main.c        **** }
 179:main.c        **** 
 180:main.c        **** static inline void recvBuffer(pagebuf_t size)
 181:main.c        **** {
 182:main.c        **** 	pagebuf_t cnt;
 183:main.c        **** 	uint8_t *tmp = gBuffer;
 184:main.c        **** 
 185:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 186:main.c        **** 		{
 187:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 188:main.c        **** 		}
 189:main.c        **** }
 190:main.c        **** 
 191:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 192:main.c        **** {
 193:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 194:main.c        **** 	uint32_t baddr = pagestart;
 195:main.c        **** 	uint16_t data;
 196:main.c        **** 	uint8_t *tmp = gBuffer;
 197:main.c        **** 
 198:main.c        **** 	do 
 199:main.c        **** 		{
 200:main.c        **** 		data = *tmp++;
 201:main.c        **** 		data |= *tmp++ << 8;
 202:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 203:main.c        **** 
 204:main.c        **** 		baddr += 2;			// Select next word in memory
 205:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 206:main.c        **** 		} 
 207:main.c        **** 	while (size);				// Loop until all bytes written
 208:main.c        **** 
 209:main.c        **** 	boot_page_write(pagestart);
 210:main.c        **** 	boot_spm_busy_wait();
 211:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 212:main.c        **** 
 213:main.c        **** 	return baddr>>1;
 214:main.c        **** }
 215:main.c        **** 
 216:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 217:main.c        **** {
 218:main.c        **** 	uint8_t *tmp = gBuffer;
 219:main.c        **** 
 220:main.c        **** 	do 
 221:main.c        **** 		{
 222:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 223:main.c        **** 		address++;			// Select next byte
 224:main.c        **** 		size--;				// Decreas number of bytes to write
 225:main.c        **** 		}
 226:main.c        **** 	while (size);				// Loop until all bytes written
 227:main.c        **** 
 228:main.c        **** 	// eeprom_busy_wait();
 229:main.c        **** 
 230:main.c        **** 	return address;
 231:main.c        **** }
 232:main.c        **** 
 233:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 234:main.c        **** {
 235:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 236:main.c        **** 	uint16_t data;
 237:main.c        **** 
 238:main.c        **** 	do 
 239:main.c        **** 	{
 240:main.c        **** 
 241:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 242:main.c        **** 
 243:main.c        **** 	#if defined(RAMPZ)
 244:main.c        **** 		data = pgm_read_word_far(baddr);
 245:main.c        **** 	#else
 246:main.c        **** 		data = pgm_read_word_near(baddr);
 247:main.c        **** 	#endif
 248:main.c        **** 
 249:main.c        **** #else
 250:main.c        **** 		// don't read bootloader
 251:main.c        **** 		if ( baddr < APP_END ) 
 252:main.c        **** 		{
 253:main.c        **** 		#if defined(RAMPZ)
 254:main.c        **** 			data = pgm_read_word_far(baddr);
 255:main.c        **** 		#else
 256:main.c        **** 			data = pgm_read_word_near(baddr);
 257:main.c        **** 		#endif
 258:main.c        **** 		}
 259:main.c        **** 		else 
 260:main.c        **** 		{
 261:main.c        **** 		data = 0xFFFF; // fake empty
 262:main.c        **** 		}
 263:main.c        **** #endif
 264:main.c        **** 		sendchar(data);			// send LSB
 265:main.c        **** 		sendchar((data >> 8));		// send MSB
 266:main.c        **** 		baddr += 2;			// Select next word in memory
 267:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 268:main.c        **** 	} 
 269:main.c        **** 	while (size);				// Repeat until block has been read
 270:main.c        **** 	return baddr>>1;
 271:main.c        **** }
 272:main.c        **** 
 273:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 274:main.c        **** {
 275:main.c        **** 	do 
 276:main.c        **** 	{
 277:main.c        **** 	sendchar( eeprom_read_byte( (uint8_t*)address ) );
 278:main.c        **** 	address++;
 279:main.c        **** 	size--;				// Decrease number of bytes to read
 280:main.c        **** 	} 
 281:main.c        **** 	while (size);				// Repeat until block has been read
 282:main.c        **** 
 283:main.c        **** 	return address;
 284:main.c        **** }
 285:main.c        **** 
 286:main.c        **** #if defined(ENABLEREADFUSELOCK)
 287:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 288:main.c        **** {
 289:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 290:main.c        **** 	uint8_t retval;
 291:main.c        **** 
 292:main.c        **** 	asm volatile
 293:main.c        **** 	(
 294:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 295:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 296:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 297:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 298:main.c        **** 		: "=m" (SPM_REG),
 299:main.c        **** 		  "=r" (retval)
 300:main.c        **** 		: "r" (mode),
 301:main.c        **** 		  "r" (addr)
 302:main.c        **** 		: "r30", "r31", "r0"
 303:main.c        **** 	);
 304:main.c        **** 	return retval;
 305:main.c        **** }
 306:main.c        **** #endif
 307:main.c        **** 
 308:main.c        **** static void send_boot(void)
 309:main.c        **** {
 164               	.LM7:
 165               	.LFBB3:
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 310:main.c        **** 	sendchar('A');
 171               	.LM8:
 172 001c 81E4      		ldi r24,lo8(65)
 173 001e 0E94 0000 		call sendchar
 311:main.c        **** 	sendchar('V');
 175               	.LM9:
 176 0022 86E5      		ldi r24,lo8(86)
 177 0024 0E94 0000 		call sendchar
 312:main.c        **** 	sendchar('R');
 179               	.LM10:
 180 0028 82E5      		ldi r24,lo8(82)
 181 002a 0E94 0000 		call sendchar
 313:main.c        **** 	sendchar('B');
 183               	.LM11:
 184 002e 82E4      		ldi r24,lo8(66)
 185 0030 0E94 0000 		call sendchar
 314:main.c        **** 	sendchar('O');
 187               	.LM12:
 188 0034 8FE4      		ldi r24,lo8(79)
 189 0036 0E94 0000 		call sendchar
 315:main.c        **** 	sendchar('O');
 191               	.LM13:
 192 003a 8FE4      		ldi r24,lo8(79)
 193 003c 0E94 0000 		call sendchar
 316:main.c        **** 	sendchar('T');
 195               	.LM14:
 196 0040 84E5      		ldi r24,lo8(84)
 197 0042 0C94 0000 		jmp sendchar
 199               	.Lscope3:
 201               	.global	__vector_default
 203               	__vector_default:
 152:main.c        **** #endif
 205               	.LM15:
 206               	.LFBB4:
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 0 */
 210               	.L__stack_usage = 0
 211 0046 0895      		ret
 213               	.Lscope4:
 214               		.section	.text.startup,"ax",@progbits
 216               	.global	main
 218               	main:
 317:main.c        **** }
 318:main.c        **** 
 319:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 320:main.c        **** 
 321:main.c        **** int main(void)
 322:main.c        **** {
 220               	.LM16:
 221               	.LFBB5:
 223               	.LM17:
 224 0000 CF93      		push r28
 225 0002 DF93      		push r29
 226 0004 1F92      		push __zero_reg__
 227 0006 CDB7      		in r28,__SP_L__
 228 0008 DEB7      		in r29,__SP_H__
 229               	/* prologue: function */
 230               	/* frame size = 1 */
 231               	/* stack size = 3 */
 232               	.L__stack_usage = 3
 323:main.c        **** 	uint16_t address = 0;
 324:main.c        **** 	uint8_t device = 0, val;
 325:main.c        **** 
 326:main.c        **** 
 327:main.c        **** 
 328:main.c        **** #ifdef ENABLE_BOOT_LED	// LED ON
 329:main.c        **** 	BIPORT |= (1<<BIPNUM);	
 234               	.LM18:
 235 000a 299A      		sbi 0x5,1
 330:main.c        **** 	BIDDR  |= (1<<BIPNUM);
 237               	.LM19:
 238 000c 219A      		sbi 0x4,1
 331:main.c        **** #endif
 332:main.c        **** 
 333:main.c        **** 
 334:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 335:main.c        **** 	#ifdef WDT_OFF_SPECIAL
 336:main.c        **** 		#warning "using target specific watchdog_off"
 337:main.c        **** 		bootloader_wdt_off();
 338:main.c        **** 	#else
 339:main.c        **** 		cli();
 240               	.LM20:
 241               	/* #APP */
 242               	 ;  339 "main.c" 1
 243 000e F894      		cli
 244               	 ;  0 "" 2
 340:main.c        **** 		wdt_reset();
 246               	.LM21:
 247               	 ;  340 "main.c" 1
 248 0010 A895      		wdr
 249               	 ;  0 "" 2
 341:main.c        **** 		MCUSR=0;
 251               	.LM22:
 252               	/* #NOAPP */
 253 0012 14BE      		out 0x34,__zero_reg__
 342:main.c        **** 	    WDTCSR|=_BV(WDCE) | _BV(WDE);
 255               	.LM23:
 256 0014 8091 6000 		lds r24,96
 257 0018 8861      		ori r24,lo8(24)
 258 001a 8093 6000 		sts 96,r24
 343:main.c        **** 	    WDTCSR=0;
 260               	.LM24:
 261 001e 1092 6000 		sts 96,__zero_reg__
 262               	.LBB32:
 263               	.LBB33:
 265               	.Ltext1:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 450:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 451:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 452:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 453:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 454:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 455:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 456:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 457:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 459:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 460:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 461:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 462:/usr/lib/avr/include/avr/wdt.h **** 		);
 463:/usr/lib/avr/include/avr/wdt.h **** 	}
 464:/usr/lib/avr/include/avr/wdt.h **** 	else
 465:/usr/lib/avr/include/avr/wdt.h **** 	{
 466:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 467:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 267               	.LM25:
 268               	/* #APP */
 269               	 ;  467 "/usr/lib/avr/include/avr/wdt.h" 1
 270 0022 0FB6      		in __tmp_reg__,__SREG__
 271 0024 F894      		cli
 272 0026 A895      		wdr
 273 0028 8091 6000 		lds r24,96
 274 002c 8861      		ori r24,24
 275 002e 8093 6000 		sts 96,r24
 276 0032 1092 6000 		sts 96,__zero_reg__
 277 0036 0FBE      		out __SREG__,__tmp_reg__
 278               		
 279               	 ;  0 "" 2
 280               	/* #NOAPP */
 281               	.LBE33:
 282               	.LBE32:
 284               	.Ltext2:
 344:main.c        **** 		wdt_disable();
 345:main.c        **** 	#endif
 346:main.c        **** #endif
 347:main.c        **** 	
 348:main.c        **** #ifdef START_POWERSAVE
 349:main.c        **** 	uint8_t OK = 1;
 350:main.c        **** #endif
 351:main.c        **** 
 352:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 286               	.LM26:
 287 0038 5298      		cbi 0xa,2
 353:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 289               	.LM27:
 290 003a 5A9A      		sbi 0xb,2
 354:main.c        **** 
 355:main.c        **** 	// Set baud rate
 356:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 292               	.LM28:
 293 003c 1092 C500 		sts 197,__zero_reg__
 357:main.c        **** 	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 295               	.LM29:
 296 0040 85E0      		ldi r24,lo8(5)
 297 0042 8093 C400 		sts 196,r24
 358:main.c        **** 
 359:main.c        **** #ifdef UART_DOUBLESPEED
 360:main.c        **** 	UART_STATUS = ( 1<<UART_DOUBLE );
 361:main.c        **** #endif
 362:main.c        **** 
 363:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 299               	.LM30:
 300 0046 88E1      		ldi r24,lo8(24)
 301 0048 8093 C100 		sts 193,r24
 364:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 303               	.LM31:
 304 004c 86E0      		ldi r24,lo8(6)
 305 004e 8093 C200 		sts 194,r24
 365:main.c        **** 	
 366:main.c        **** #if defined(START_POWERSAVE)
 367:main.c        **** 	/*
 368:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 369:main.c        **** 		It may look a little strange but separating the login-loop from
 370:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 371:main.c        **** 	    etc.).
 372:main.c        **** 	*/
 373:main.c        **** 	for(;OK;) 
 374:main.c        **** 	{
 375:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 376:main.c        **** 		{
 377:main.c        **** 		// jump to main app if pin is not grounded
 378:main.c        **** 		BLPORT &= ~(1<<BLPNUM);	// set to default
 379:main.c        **** 
 380:main.c        **** 		#ifdef UART_DOUBLESPEED
 381:main.c        **** 			UART_STATUS &= ~( 1<<UART_DOUBLE );
 382:main.c        **** 		#endif
 383:main.c        **** 
 384:main.c        **** 
 385:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 386:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 387:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 388:main.c        **** 		#endif
 389:main.c        **** 
 390:main.c        **** 		jump_to_app();		// Jump to application sector
 391:main.c        **** 
 392:main.c        **** 		} 
 393:main.c        **** 		else 
 394:main.c        **** 		{
 395:main.c        **** 		val = recvchar();
 396:main.c        **** 		/* ESC */
 397:main.c        **** 			if (val == 0x1B) 
 398:main.c        **** 			{
 399:main.c        **** 				// AVRPROG connection
 400:main.c        **** 				// Wait for signon
 401:main.c        **** 				while (val != 'S')
 402:main.c        **** 				val = recvchar();
 403:main.c        **** 				
 404:main.c        **** 				send_boot();			// Report signon
 405:main.c        **** 				OK = 0;
 406:main.c        **** 			} 
 407:main.c        **** 			else 
 408:main.c        **** 			{
 409:main.c        **** 			sendchar('?');
 410:main.c        **** 			}
 411:main.c        **** 	    }
 412:main.c        **** 		// Power-Save code here
 413:main.c        **** 	}
 414:main.c        **** 
 415:main.c        **** #elif defined(START_SIMPLE)
 416:main.c        **** 
 417:main.c        **** 	if ((BLPIN & (1<<BLPNUM))) {
 418:main.c        **** 		// jump to main app if pin is not grounded
 419:main.c        **** 		BLPORT &= ~(1<<BLPNUM);		// set to default	
 420:main.c        **** 			
 421:main.c        **** 	#ifdef UART_DOUBLESPEED
 422:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 423:main.c        **** 	#endif
 424:main.c        **** 
 425:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 426:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 427:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 428:main.c        **** 		#endif
 429:main.c        **** 
 430:main.c        **** 		jump_to_app();			// Jump to application sector
 431:main.c        **** 	}
 432:main.c        **** 
 433:main.c        **** #elif defined(START_WAIT)
 434:main.c        **** 
 435:main.c        **** 	PWRPORT |=  (1<<PWRPNUM); // TURN ON Bluetooth module
 307               	.LM32:
 308 0052 5F9A      		sbi 0xb,7
 436:main.c        **** 	PWRDDR  |=  (1<<PWRPNUM);
 310               	.LM33:
 311 0054 579A      		sbi 0xa,7
 312 0056 E12C      		mov r14,__zero_reg__
 313 0058 F12C      		mov r15,__zero_reg__
 437:main.c        **** 
 438:main.c        **** 	uint16_t cnt = 0;
 439:main.c        **** 
 440:main.c        **** 	while (1) {
 441:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 442:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 443:main.c        **** 				break;
 444:main.c        **** 
 445:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 446:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 447:main.c        **** 
 448:main.c        **** 
 449:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 450:main.c        **** 			BIPORT &= ~(1<<BIPNUM);	
 451:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 452:main.c        **** 			#endif
 453:main.c        **** 			jump_to_app();			// Jump to application sector
 315               	.LM34:
 316 005a 00E0      		ldi r16,0
 317 005c 10E0      		ldi r17,0
 318               	.L15:
 441:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 320               	.LM35:
 321 005e 8091 C000 		lds r24,192
 322 0062 87FF      		sbrs r24,7
 323 0064 00C0      		rjmp .L12
 442:main.c        **** 				break;
 325               	.LM36:
 326 0066 8091 C600 		lds r24,198
 327 006a 8335      		cpi r24,lo8(83)
 328 006c 01F0      		breq .L13
 329               	.L12:
 445:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 331               	.LM37:
 332 006e 80E2      		ldi r24,32
 333 0070 E816      		cp r14,r24
 334 0072 83E0      		ldi r24,3
 335 0074 F806      		cpc r15,r24
 336 0076 00F0      		brlo .L14
 446:main.c        **** 
 338               	.LM38:
 339 0078 5A98      		cbi 0xb,2
 450:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 341               	.LM39:
 342 007a 2998      		cbi 0x5,1
 451:main.c        **** 			#endif
 344               	.LM40:
 345 007c 2198      		cbi 0x4,1
 347               	.LM41:
 348 007e F801      		movw r30,r16
 349 0080 0995      		icall
 350               	.L14:
 351               	.LBB34:
 352               	.LBB35:
 354               	.Ltext3:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 356               	.LM42:
 357 0082 8FEF      		ldi r24,lo8(9215)
 358 0084 93E2      		ldi r25,hi8(9215)
 359 0086 0197      	1:	sbiw r24,1
 360 0088 01F4      		brne 1b
 361 008a 00C0      		rjmp .
 362 008c 0000      		nop
 363 008e 9FEF      		ldi r25,-1
 364 0090 E91A      		sub r14,r25
 365 0092 F90A      		sbc r15,r25
 366 0094 00C0      		rjmp .L15
 367               	.L13:
 368               	.LBE35:
 369               	.LBE34:
 371               	.Ltext4:
 454:main.c        **** 		}
 455:main.c        **** 
 456:main.c        **** 		_delay_ms(10);
 457:main.c        **** 	}
 458:main.c        **** 	send_boot();
 373               	.LM43:
 374 0096 0E94 0000 		call send_boot
 324:main.c        **** 
 376               	.LM44:
 377 009a 10E0      		ldi r17,0
 323:main.c        **** 	uint8_t device = 0, val;
 379               	.LM45:
 380 009c 612C      		mov r6,__zero_reg__
 381 009e 712C      		mov r7,__zero_reg__
 382               	.LBB36:
 383               	.LBB37:
 385               	.Ltext5:
 425:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 387               	.LM46:
 388 00a0 78E1      		ldi r23,lo8(24)
 389 00a2 972E      		mov r9,r23
 390 00a4 ECE0      		ldi r30,lo8(12)
 391 00a6 8E2E      		mov r8,r30
 392               	.LBE37:
 393               	.LBE36:
 394               	.LBB39:
 395               	.LBB40:
 397               	.Ltext6:
 173:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 399               	.LM47:
 400 00a8 F3E0      		ldi r31,lo8(3)
 401 00aa 2F2E      		mov r2,r31
 177:main.c        **** }
 403               	.LM48:
 404 00ac 01E1      		ldi r16,lo8(17)
 405 00ae A0E0      		ldi r26,lo8(gBuffer)
 406 00b0 AA2E      		mov r10,r26
 407 00b2 A0E0      		ldi r26,hi8(gBuffer)
 408 00b4 BA2E      		mov r11,r26
 409               	.L16:
 410               	.LBE40:
 411               	.LBE39:
 459:main.c        **** 
 460:main.c        **** #elif defined(START_BOOTICE)
 461:main.c        **** #warning "BOOTICE mode - no startup-condition"
 462:main.c        **** 
 463:main.c        **** #else
 464:main.c        **** #error "Select START_ condition for bootloader in main.c"
 465:main.c        **** #endif
 466:main.c        **** 
 467:main.c        **** 
 468:main.c        **** 	for(;;) 
 469:main.c        **** 	{
 470:main.c        **** 		val = recvchar();
 413               	.LM49:
 414 00b6 0E94 0000 		call recvchar
 471:main.c        **** 		// Autoincrement?
 472:main.c        **** 		if (val == 'a') 
 416               	.LM50:
 417 00ba 8136      		cpi r24,lo8(97)
 418 00bc 01F4      		brne .L17
 473:main.c        **** 		{
 474:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 420               	.LM51:
 421 00be 89E5      		ldi r24,lo8(89)
 422 00c0 00C0      		rjmp .L60
 423               	.L17:
 475:main.c        **** 
 476:main.c        **** 		//write address
 477:main.c        **** 		} 
 478:main.c        **** 		else if (val == 'A') 
 425               	.LM52:
 426 00c2 8134      		cpi r24,lo8(65)
 427 00c4 01F4      		brne .L19
 479:main.c        **** 		{
 480:main.c        **** 			address = recvchar();		//read address 8 MSB
 429               	.LM53:
 430 00c6 0E94 0000 		call recvchar
 431 00ca 682E      		mov r6,r24
 432 00cc 712C      		mov r7,__zero_reg__
 481:main.c        **** 			address = (address<<8) | recvchar();
 434               	.LM54:
 435 00ce 762C      		mov r7,r6
 436 00d0 6624      		clr r6
 437 00d2 0E94 0000 		call recvchar
 438 00d6 682A      		or r6,r24
 439 00d8 00C0      		rjmp .L61
 440               	.L19:
 482:main.c        **** 			sendchar('\r');
 483:main.c        **** 
 484:main.c        **** 		// Buffer load support
 485:main.c        **** 		} 
 486:main.c        **** 		else if (val == 'b') 
 442               	.LM55:
 443 00da 8236      		cpi r24,lo8(98)
 444 00dc 01F4      		brne .L20
 487:main.c        **** 		{
 488:main.c        **** 			sendchar('Y');					// Report buffer load supported
 446               	.LM56:
 447 00de 89E5      		ldi r24,lo8(89)
 448 00e0 0E94 0000 		call sendchar
 489:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 450               	.LM57:
 451 00e4 80E0      		ldi r24,0
 452 00e6 0E94 0000 		call sendchar
 490:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 454               	.LM58:
 455 00ea 80E8      		ldi r24,lo8(-128)
 456 00ec 00C0      		rjmp .L60
 457               	.L20:
 491:main.c        **** 
 492:main.c        **** 		// Start buffer load
 493:main.c        **** 		} 
 494:main.c        **** 		else if (val == 'B') 
 459               	.LM59:
 460 00ee 8234      		cpi r24,lo8(66)
 461 00f0 01F0      		breq .+2
 462 00f2 00C0      		rjmp .L21
 463               	.LBB42:
 495:main.c        **** 		{
 496:main.c        **** 			pagebuf_t size;
 497:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 465               	.LM60:
 466 00f4 0E94 0000 		call recvchar
 498:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 468               	.LM61:
 469 00f8 0E94 0000 		call recvchar
 470 00fc 482E      		mov r4,r24
 499:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 472               	.LM62:
 473 00fe 0E94 0000 		call recvchar
 474 0102 982F      		mov r25,r24
 475 0104 50E0      		ldi r21,lo8(gBuffer)
 476 0106 E52E      		mov r14,r21
 477 0108 50E0      		ldi r21,hi8(gBuffer)
 478 010a F52E      		mov r15,r21
 479               	.LBB43:
 480               	.LBB44:
 185:main.c        **** 		{
 482               	.LM63:
 483 010c D12C      		mov r13,__zero_reg__
 484               	.L23:
 187:main.c        **** 		}
 486               	.LM64:
 487 010e D414      		cp r13,r4
 488 0110 00F4      		brsh .L49
 489 0112 9983      		std Y+1,r25
 490 0114 0E94 0000 		call recvchar
 491 0118 9981      		ldd r25,Y+1
 492 011a 00C0      		rjmp .L22
 493               	.L49:
 494 011c 8FEF      		ldi r24,lo8(-1)
 495               	.L22:
 496 011e F701      		movw r30,r14
 497 0120 8193      		st Z+,r24
 498 0122 7F01      		movw r14,r30
 185:main.c        **** 		{
 500               	.LM65:
 501 0124 D394      		inc r13
 502 0126 F0E8      		ldi r31,lo8(-128)
 503 0128 DF12      		cpse r13,r31
 504 012a 00C0      		rjmp .L23
 505               	.LBE44:
 506               	.LBE43:
 500:main.c        **** 			recvBuffer(size);
 501:main.c        **** 
 502:main.c        **** 			if (device == DEVTYPE) 
 508               	.LM66:
 509 012c 1537      		cpi r17,lo8(117)
 510 012e 01F0      		breq .+2
 511 0130 00C0      		rjmp .L62
 503:main.c        **** 			{
 504:main.c        **** 				if (val == 'F') 
 513               	.LM67:
 514 0132 9634      		cpi r25,lo8(70)
 515 0134 01F0      		breq .+2
 516 0136 00C0      		rjmp .L25
 517               	.LBB45:
 518               	.LBB46:
 193:main.c        **** 	uint32_t baddr = pagestart;
 520               	.LM68:
 521 0138 6301      		movw r12,r6
 522 013a E12C      		mov r14,__zero_reg__
 523 013c F12C      		mov r15,__zero_reg__
 524 013e CC0C      		lsl r12
 525 0140 DD1C      		rol r13
 526 0142 EE1C      		rol r14
 527 0144 FF1C      		rol r15
 196:main.c        **** 
 529               	.LM69:
 530 0146 2091 0000 		lds r18,gBuffer
 194:main.c        **** 	uint16_t data;
 532               	.LM70:
 533 014a B701      		movw r22,r14
 534 014c A601      		movw r20,r12
 196:main.c        **** 
 536               	.LM71:
 537 014e A0E0      		ldi r26,lo8(gBuffer)
 538 0150 B0E0      		ldi r27,hi8(gBuffer)
 539               	.L27:
 540 0152 1296      		adiw r26,2
 541 0154 FD01      		movw r30,r26
 542 0156 3197      		sbiw r30,1
 201:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 544               	.LM72:
 545 0158 8081      		ld r24,Z
 546 015a 30E0      		ldi r19,0
 547 015c 382B      		or r19,r24
 202:main.c        **** 
 549               	.LM73:
 550 015e 81E0      		ldi r24,lo8(1)
 551 0160 FA01      		movw r30,r20
 552               	/* #APP */
 553               	 ;  202 "main.c" 1
 554 0162 0901      		movw  r0, r18
 555 0164 8093 5700 		sts 87, r24
 556 0168 E895      		spm
 557 016a 1124      		clr  r1
 558               		
 559               	 ;  0 "" 2
 204:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 561               	.LM74:
 562               	/* #NOAPP */
 563 016c 4E5F      		subi r20,-2
 564 016e 5F4F      		sbci r21,-1
 565 0170 6F4F      		sbci r22,-1
 566 0172 7F4F      		sbci r23,-1
 567 0174 8A2D      		mov r24,r10
 568 0176 8A1B      		sub r24,r26
 569 0178 840D      		add r24,r4
 207:main.c        **** 
 571               	.LM75:
 572 017a 01F0      		breq .L26
 201:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 574               	.LM76:
 575 017c 2C91      		ld r18,X
 576 017e 00C0      		rjmp .L27
 577               	.L26:
 209:main.c        **** 	boot_spm_busy_wait();
 579               	.LM77:
 580 0180 85E0      		ldi r24,lo8(5)
 581 0182 F601      		movw r30,r12
 582               	/* #APP */
 583               	 ;  209 "main.c" 1
 584 0184 8093 5700 		sts 87, r24
 585 0188 E895      		spm
 586               		
 587               	 ;  0 "" 2
 588               	/* #NOAPP */
 589               	.L28:
 210:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 591               	.LM78:
 592 018a 07B6      		in __tmp_reg__,0x37
 593 018c 00FC      		sbrc __tmp_reg__,0
 594 018e 00C0      		rjmp .L28
 211:main.c        **** 
 596               	.LM79:
 597               	/* #APP */
 598               	 ;  211 "main.c" 1
 599 0190 0093 5700 		sts 87, r16
 600 0194 E895      		spm
 601               		
 602               	 ;  0 "" 2
 213:main.c        **** }
 604               	.LM80:
 605               	/* #NOAPP */
 606 0196 DB01      		movw r26,r22
 607 0198 CA01      		movw r24,r20
 608 019a B695      		lsr r27
 609 019c A795      		ror r26
 610 019e 9795      		ror r25
 611 01a0 8795      		ror r24
 612 01a2 3C01      		movw r6,r24
 613               	.LBE46:
 614               	.LBE45:
 615 01a4 00C0      		rjmp .L61
 616               	.L25:
 505:main.c        **** 				{
 506:main.c        **** 				address = writeFlashPage(address, size);
 507:main.c        **** 				} 
 508:main.c        **** 				else if (val == 'E') 
 618               	.LM81:
 619 01a6 9534      		cpi r25,lo8(69)
 620 01a8 01F0      		breq .+2
 621 01aa 00C0      		rjmp .L61
 622 01ac 20E0      		ldi r18,lo8(gBuffer)
 623 01ae E22E      		mov r14,r18
 624 01b0 20E0      		ldi r18,hi8(gBuffer)
 625 01b2 F22E      		mov r15,r18
 626 01b4 6301      		movw r12,r6
 627 01b6 342C      		mov r3,r4
 628 01b8 3A0C      		add r3,r10
 629               	.L30:
 630               	.LBB47:
 631               	.LBB48:
 222:main.c        **** 		address++;			// Select next byte
 633               	.LM82:
 634 01ba F701      		movw r30,r14
 635 01bc 6191      		ld r22,Z+
 636 01be 7F01      		movw r14,r30
 637 01c0 C601      		movw r24,r12
 638 01c2 0E94 0000 		call eeprom_write_byte
 223:main.c        **** 		size--;				// Decreas number of bytes to write
 640               	.LM83:
 641 01c6 FFEF      		ldi r31,-1
 642 01c8 CF1A      		sub r12,r31
 643 01ca DF0A      		sbc r13,r31
 226:main.c        **** 
 645               	.LM84:
 646 01cc 3E10      		cpse r3,r14
 647 01ce 00C0      		rjmp .L30
 648 01d0 8FEF      		ldi r24,-1
 649 01d2 681A      		sub r6,r24
 650 01d4 780A      		sbc r7,r24
 651 01d6 8FEF      		ldi r24,lo8(-1)
 652 01d8 840D      		add r24,r4
 653 01da 680E      		add r6,r24
 654 01dc 711C      		adc r7,__zero_reg__
 655 01de 00C0      		rjmp .L61
 656               	.L21:
 657               	.LBE48:
 658               	.LBE47:
 659               	.LBE42:
 509:main.c        **** 				{
 510:main.c        **** 				address = writeEEpromPage(address, size);
 511:main.c        **** 				}
 512:main.c        **** 				sendchar('\r');
 513:main.c        **** 			} 
 514:main.c        **** 			else 
 515:main.c        **** 			{
 516:main.c        **** 			sendchar(0);
 517:main.c        **** 			}
 518:main.c        **** 
 519:main.c        **** 		// Block read
 520:main.c        **** 		} 
 521:main.c        **** 		else if (val == 'g') 
 661               	.LM85:
 662 01e0 8736      		cpi r24,lo8(103)
 663 01e2 01F0      		breq .+2
 664 01e4 00C0      		rjmp .L31
 665               	.LBB49:
 522:main.c        **** 		{
 523:main.c        **** 			pagebuf_t size;
 524:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 667               	.LM86:
 668 01e6 0E94 0000 		call recvchar
 525:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 670               	.LM87:
 671 01ea 0E94 0000 		call recvchar
 672 01ee F82E      		mov r15,r24
 526:main.c        **** 			val = recvchar();				// Get memtype
 674               	.LM88:
 675 01f0 0E94 0000 		call recvchar
 527:main.c        **** 
 528:main.c        **** 			if (val == 'F') 
 677               	.LM89:
 678 01f4 8634      		cpi r24,lo8(70)
 679 01f6 01F4      		brne .L32
 680               	.LBB50:
 681               	.LBB51:
 235:main.c        **** 	uint16_t data;
 683               	.LM90:
 684 01f8 A301      		movw r20,r6
 685 01fa 60E0      		ldi r22,0
 686 01fc 70E0      		ldi r23,0
 687 01fe 2A01      		movw r4,r20
 688 0200 3B01      		movw r6,r22
 689 0202 440C      		lsl r4
 690 0204 551C      		rol r5
 691 0206 661C      		rol r6
 692 0208 771C      		rol r7
 693 020a DF2C      		mov r13,r15
 694 020c D40C      		add r13,r4
 695               	.L33:
 696               	.LBB52:
 246:main.c        **** 	#endif
 698               	.LM91:
 699 020e F201      		movw r30,r4
 700               	/* #APP */
 701               	 ;  246 "main.c" 1
 702 0210 E590      		lpm r14, Z+
 703 0212 F490      		lpm r15, Z
 704               		
 705               	 ;  0 "" 2
 706               	/* #NOAPP */
 707               	.LBE52:
 264:main.c        **** 		sendchar((data >> 8));		// send MSB
 709               	.LM92:
 710 0214 8E2D      		mov r24,r14
 711 0216 0E94 0000 		call sendchar
 265:main.c        **** 		baddr += 2;			// Select next word in memory
 713               	.LM93:
 714 021a 8F2D      		mov r24,r15
 715 021c 0E94 0000 		call sendchar
 266:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 717               	.LM94:
 718 0220 92E0      		ldi r25,2
 719 0222 490E      		add r4,r25
 720 0224 511C      		adc r5,__zero_reg__
 721 0226 611C      		adc r6,__zero_reg__
 722 0228 711C      		adc r7,__zero_reg__
 269:main.c        **** 	return baddr>>1;
 724               	.LM95:
 725 022a D410      		cpse r13,r4
 726 022c 00C0      		rjmp .L33
 270:main.c        **** }
 728               	.LM96:
 729 022e B301      		movw r22,r6
 730 0230 A201      		movw r20,r4
 731 0232 7695      		lsr r23
 732 0234 6795      		ror r22
 733 0236 5795      		ror r21
 734 0238 4795      		ror r20
 735 023a 3A01      		movw r6,r20
 736               	.LBE51:
 737               	.LBE50:
 738 023c 00C0      		rjmp .L16
 739               	.L32:
 529:main.c        **** 			{
 530:main.c        **** 			address = readFlashPage(address, size);
 531:main.c        **** 			} 
 532:main.c        **** 			else if (val == 'E') 
 741               	.LM97:
 742 023e 8534      		cpi r24,lo8(69)
 743 0240 01F0      		breq .+2
 744 0242 00C0      		rjmp .L16
 745 0244 6301      		movw r12,r6
 746 0246 E62C      		mov r14,r6
 747 0248 EF0C      		add r14,r15
 748               	.L34:
 749               	.LBB53:
 750               	.LBB54:
 277:main.c        **** 	address++;
 752               	.LM98:
 753 024a C601      		movw r24,r12
 754 024c 0E94 0000 		call eeprom_read_byte
 755 0250 0E94 0000 		call sendchar
 278:main.c        **** 	size--;				// Decrease number of bytes to read
 757               	.LM99:
 758 0254 EFEF      		ldi r30,-1
 759 0256 CE1A      		sub r12,r30
 760 0258 DE0A      		sbc r13,r30
 281:main.c        **** 
 762               	.LM100:
 763 025a EC10      		cpse r14,r12
 764 025c 00C0      		rjmp .L34
 765 025e FFEF      		ldi r31,-1
 766 0260 6F1A      		sub r6,r31
 767 0262 7F0A      		sbc r7,r31
 768 0264 FA94      		dec r15
 769 0266 6F0C      		add r6,r15
 770 0268 711C      		adc r7,__zero_reg__
 771 026a 00C0      		rjmp .L16
 772               	.L31:
 773               	.LBE54:
 774               	.LBE53:
 775               	.LBE49:
 533:main.c        **** 			{
 534:main.c        **** 			address = readEEpromPage(address, size);
 535:main.c        **** 			}
 536:main.c        **** 
 537:main.c        **** 		// Chip erase
 538:main.c        ****  		} 
 539:main.c        **** 		else if (val == 'e') 
 777               	.LM101:
 778 026c 8536      		cpi r24,lo8(101)
 779 026e 01F4      		brne .L35
 540:main.c        **** 		{
 541:main.c        **** 		if (device == DEVTYPE) 
 781               	.LM102:
 782 0270 1537      		cpi r17,lo8(117)
 783 0272 01F0      		breq .+2
 784 0274 00C0      		rjmp .L61
 785 0276 E0E0      		ldi r30,0
 786 0278 F0E0      		ldi r31,0
 787               	.L38:
 788               	.LBB55:
 789               	.LBB41:
 173:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 791               	.LM103:
 792               	/* #APP */
 793               	 ;  173 "main.c" 1
 794 027a 2092 5700 		sts 87, r2
 795 027e E895      		spm
 796               		
 797               	 ;  0 "" 2
 798               	/* #NOAPP */
 799               	.L37:
 174:main.c        **** 		addr += SPM_PAGESIZE;
 801               	.LM104:
 802 0280 07B6      		in __tmp_reg__,0x37
 803 0282 00FC      		sbrc __tmp_reg__,0
 804 0284 00C0      		rjmp .L37
 805 0286 E058      		subi r30,-128
 806 0288 FF4F      		sbci r31,-1
 171:main.c        **** 		{
 808               	.LM105:
 809 028a E115      		cp r30,__zero_reg__
 810 028c 88E3      		ldi r24,56
 811 028e F807      		cpc r31,r24
 812 0290 01F4      		brne .L38
 177:main.c        **** }
 814               	.LM106:
 815               	/* #APP */
 816               	 ;  177 "main.c" 1
 817 0292 0093 5700 		sts 87, r16
 818 0296 E895      		spm
 819               		
 820               	 ;  0 "" 2
 821               	/* #NOAPP */
 822 0298 00C0      		rjmp .L61
 823               	.L35:
 824               	.LBE41:
 825               	.LBE55:
 542:main.c        **** 			{
 543:main.c        **** 			eraseFlash();
 544:main.c        **** 			}
 545:main.c        **** 		sendchar('\r');
 546:main.c        **** 
 547:main.c        **** 		// Exit upgrade
 548:main.c        **** 		} 
 549:main.c        **** 		else if (val == 'E') 
 827               	.LM107:
 828 029a 8534      		cpi r24,lo8(69)
 829 029c 01F4      		brne .L39
 830               	.LBB56:
 831               	.LBB38:
 833               	.Ltext7:
 425:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 835               	.LM108:
 836               	/* #APP */
 837               	 ;  425 "/usr/lib/avr/include/avr/wdt.h" 1
 838 029e 0FB6      		in __tmp_reg__,__SREG__
 839 02a0 F894      		cli
 840 02a2 A895      		wdr
 841 02a4 9092 6000 		sts 96, r9
 842 02a8 0FBE      		out __SREG__,__tmp_reg__
 843 02aa 8092 6000 		sts 96, r8
 844               	 	
 845               	 ;  0 "" 2
 846               	/* #NOAPP */
 847 02ae 00C0      		rjmp .L61
 848               	.L39:
 849               	.LBE38:
 850               	.LBE56:
 852               	.Ltext8:
 550:main.c        **** 		{
 551:main.c        **** 		wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
 552:main.c        **** 		sendchar('\r');
 553:main.c        **** 
 554:main.c        **** 		#ifdef WRITELOCKBITS
 555:main.c        **** 			#warning "Extension 'WriteLockBits' enabled"
 556:main.c        **** 			// TODO: does not work reliably
 557:main.c        **** 			// write lockbits
 558:main.c        **** 			} 
 559:main.c        **** 			else if (val == 'l') 
 560:main.c        **** 			{
 561:main.c        **** 			if (device == DEVTYPE) 
 562:main.c        **** 				{
 563:main.c        **** 				// write_lock_bits(recvchar());
 564:main.c        **** 				boot_lock_bits_set(recvchar());	// boot.h takes care of mask
 565:main.c        **** 				boot_spm_busy_wait();
 566:main.c        **** 				}
 567:main.c        **** 			sendchar('\r');
 568:main.c        **** 		#endif
 569:main.c        **** 		// Enter programming mode
 570:main.c        **** 		} 
 571:main.c        **** 		else if (val == 'P') 
 854               	.LM109:
 855 02b0 8035      		cpi r24,lo8(80)
 856 02b2 01F0      		breq .L61
 572:main.c        **** 		{
 573:main.c        **** 		sendchar('\r');
 574:main.c        **** 
 575:main.c        **** 		// Leave programming mode
 576:main.c        **** 		} 
 577:main.c        **** 		else if (val == 'L') 
 858               	.LM110:
 859 02b4 8C34      		cpi r24,lo8(76)
 860 02b6 01F0      		breq .L61
 578:main.c        **** 		{
 579:main.c        **** 		sendchar('\r');
 580:main.c        **** 		// return programmer type
 581:main.c        **** 		} 
 582:main.c        **** 		else if (val == 'p') 
 862               	.LM111:
 863 02b8 8037      		cpi r24,lo8(112)
 864 02ba 01F4      		brne .L42
 583:main.c        **** 		{
 584:main.c        **** 		sendchar('S');		// always serial programmer
 866               	.LM112:
 867 02bc 83E5      		ldi r24,lo8(83)
 868 02be 00C0      		rjmp .L60
 869               	.L42:
 585:main.c        **** 
 586:main.c        **** 		#ifdef ENABLEREADFUSELOCK
 587:main.c        **** 			#warning "Extension 'ReadFuseLock' enabled"
 588:main.c        **** 			// read "low" fuse bits
 589:main.c        **** 			} 
 590:main.c        **** 			else if (val == 'F') 
 591:main.c        **** 			{
 592:main.c        **** 			sendchar(read_fuse_lock(GET_LOW_FUSE_BITS));
 593:main.c        **** 
 594:main.c        **** 			// read lock bits
 595:main.c        **** 			} 
 596:main.c        **** 			else if (val == 'r') 
 597:main.c        **** 			{
 598:main.c        **** 			sendchar(read_fuse_lock(GET_LOCK_BITS));
 599:main.c        **** 
 600:main.c        **** 			// read high fuse bits
 601:main.c        **** 			} 
 602:main.c        **** 			else if (val == 'N') 
 603:main.c        **** 			{
 604:main.c        **** 			sendchar(read_fuse_lock(GET_HIGH_FUSE_BITS));
 605:main.c        **** 			// read extended fuse bits
 606:main.c        **** 			} 
 607:main.c        **** 			else if (val == 'Q') 
 608:main.c        **** 			{
 609:main.c        **** 			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
 610:main.c        **** 			#endif
 611:main.c        **** 
 612:main.c        **** 		// Return device type
 613:main.c        **** 		} 
 614:main.c        **** 		else if (val == 't') 
 871               	.LM113:
 872 02c0 8437      		cpi r24,lo8(116)
 873 02c2 01F4      		brne .L43
 615:main.c        **** 		{
 616:main.c        **** 		sendchar(DEVTYPE);
 875               	.LM114:
 876 02c4 85E7      		ldi r24,lo8(117)
 877 02c6 0E94 0000 		call sendchar
 878               	.L62:
 617:main.c        **** 		sendchar(0);
 880               	.LM115:
 881 02ca 80E0      		ldi r24,0
 882 02cc 00C0      		rjmp .L60
 883               	.L43:
 618:main.c        **** 		// clear and set LED ignored
 619:main.c        **** 		} 
 620:main.c        **** 		else if ((val == 'x') || (val == 'y')) 
 885               	.LM116:
 886 02ce 98E8      		ldi r25,lo8(-120)
 887 02d0 980F      		add r25,r24
 888 02d2 9230      		cpi r25,lo8(2)
 889 02d4 00F4      		brsh .L44
 621:main.c        **** 		{
 622:main.c        **** 		recvchar();
 891               	.LM117:
 892 02d6 0E94 0000 		call recvchar
 893 02da 00C0      		rjmp .L61
 894               	.L44:
 623:main.c        **** 		sendchar('\r');
 624:main.c        **** 
 625:main.c        **** 		// set device
 626:main.c        **** 		} 
 627:main.c        **** 		else if (val == 'T') 
 896               	.LM118:
 897 02dc 8435      		cpi r24,lo8(84)
 898 02de 01F4      		brne .L45
 628:main.c        **** 		{
 629:main.c        **** 		device = recvchar();
 900               	.LM119:
 901 02e0 0E94 0000 		call recvchar
 902 02e4 182F      		mov r17,r24
 903               	.L61:
 630:main.c        **** 		sendchar('\r');
 905               	.LM120:
 906 02e6 8DE0      		ldi r24,lo8(13)
 907 02e8 00C0      		rjmp .L60
 908               	.L45:
 631:main.c        **** 		// Return software identifier
 632:main.c        **** 		} 
 633:main.c        **** 		else if (val == 'S') 
 910               	.LM121:
 911 02ea 8335      		cpi r24,lo8(83)
 912 02ec 01F4      		brne .L46
 634:main.c        **** 		{
 635:main.c        **** 		send_boot();
 914               	.LM122:
 915 02ee 0E94 0000 		call send_boot
 916 02f2 00C0      		rjmp .L16
 917               	.L46:
 636:main.c        **** 
 637:main.c        **** 		// Return Software Version
 638:main.c        **** 		} 
 639:main.c        **** 		else if (val == 'V') {
 919               	.LM123:
 920 02f4 8635      		cpi r24,lo8(86)
 921 02f6 01F4      		brne .L47
 640:main.c        **** 		sendchar(VERSION_HIGH);
 923               	.LM124:
 924 02f8 80E3      		ldi r24,lo8(48)
 925 02fa 0E94 0000 		call sendchar
 641:main.c        **** 		sendchar(VERSION_LOW);
 927               	.LM125:
 928 02fe 88E3      		ldi r24,lo8(56)
 929 0300 00C0      		rjmp .L60
 930               	.L47:
 642:main.c        **** 
 643:main.c        **** 		// Return Signature Bytes (it seems that 
 644:main.c        **** 		// AVRProg expects the "Atmel-byte" 0x1E last
 645:main.c        **** 		// but shows it first in the dialog-window)
 646:main.c        **** 		} 
 647:main.c        **** 		else if (val == 's') 
 932               	.LM126:
 933 0302 8337      		cpi r24,lo8(115)
 934 0304 01F4      		brne .L48
 648:main.c        **** 		{
 649:main.c        **** 		sendchar(SIG_BYTE3);
 936               	.LM127:
 937 0306 8BE0      		ldi r24,lo8(11)
 938 0308 0E94 0000 		call sendchar
 650:main.c        **** 		sendchar(SIG_BYTE2);
 940               	.LM128:
 941 030c 84E9      		ldi r24,lo8(-108)
 942 030e 0E94 0000 		call sendchar
 651:main.c        **** 		sendchar(SIG_BYTE1);
 944               	.LM129:
 945 0312 8EE1      		ldi r24,lo8(30)
 946 0314 00C0      		rjmp .L60
 947               	.L48:
 652:main.c        **** 
 653:main.c        **** 		/* ESC */
 654:main.c        **** 		} 
 655:main.c        **** 		else if(val != 0x1b) 
 949               	.LM130:
 950 0316 8B31      		cpi r24,lo8(27)
 951 0318 01F4      		brne .+2
 952 031a 00C0      		rjmp .L16
 656:main.c        **** 		{
 657:main.c        **** 		sendchar('?');
 954               	.LM131:
 955 031c 8FE3      		ldi r24,lo8(63)
 956               	.L60:
 957 031e 0E94 0000 		call sendchar
 958 0322 00C0      		rjmp .L16
 972               	.Lscope5:
 973               		.comm	gBuffer,128,1
 975               		.text
 977               	.Letext0:
 978               		.ident	"GCC: (GNU) 4.9.2"
 979               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccdZPUIa.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccdZPUIa.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccdZPUIa.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccdZPUIa.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccdZPUIa.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccdZPUIa.s:116    .text:0000000000000000 sendchar
     /tmp/ccdZPUIa.s:138    .text:000000000000000e recvchar
     /tmp/ccdZPUIa.s:162    .text:000000000000001c send_boot
     /tmp/ccdZPUIa.s:203    .text:0000000000000046 __vector_default
     /tmp/ccdZPUIa.s:218    .text.startup:0000000000000000 main
                            *COM*:0000000000000080 gBuffer

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_read_byte
__do_clear_bss
